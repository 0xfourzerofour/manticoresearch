<?xml version="1.0" encoding="utf-8"?>
<test>
<name>PREPARE/EXECUTE advanced scenarios and edge cases</name>

<requires><force-rt/></requires>
<skip_indexer/>

<config>
searchd
{
	<searchd_settings/>
	data_dir = <data_path/>
}
</config>

<sphqueries>
<sphinxql>
<!-- Create tables for advanced testing -->
CREATE TABLE articles(id BIGINT, title TEXT, content TEXT, category_id INTEGER, publish_date TIMESTAMP, tags JSON);
CREATE TABLE categories(id BIGINT, name TEXT, parent_id INTEGER);

<!-- Insert test data with full-text content -->
INSERT INTO articles(id, title, content, category_id, publish_date, tags) VALUES 
(1, 'Introduction to Databases', 'This article covers the fundamentals of database systems and SQL queries', 1, 1672531200, '{"type": "tutorial", "difficulty": "beginner"}'),
(2, 'Advanced Search Techniques', 'Learn how to use full-text search and complex queries effectively', 1, 1672617600, '{"type": "advanced", "difficulty": "expert"}'),
(3, 'Performance Optimization', 'Best practices for optimizing database performance and query execution', 2, 1672704000, '{"type": "guide", "difficulty": "intermediate"}'),
(4, 'Data Migration Strategies', 'Comprehensive guide to migrating data between different database systems', 2, 1672790400, '{"type": "guide", "difficulty": "advanced"}');

INSERT INTO categories(id, name, parent_id) VALUES
(1, 'Tutorials', 0),
(2, 'Guides', 0),
(3, 'News', 0);

<!-- Test 1: Simple WHERE clauses with text search -->
PREPARE text_search FROM 'SELECT id, title FROM articles WHERE title LIKE "%Database%"';
EXECUTE text_search;

PREPARE content_search FROM 'SELECT id, title FROM articles WHERE content LIKE "%performance%"';
EXECUTE content_search;

<!-- Test 2: Cross-table queries without JOIN syntax -->
PREPARE cross_table FROM 'SELECT a.id, a.title FROM articles a WHERE a.category_id IN (SELECT c.id FROM categories c WHERE c.name = "Tutorials")';
EXECUTE cross_table;

<!-- Test 3: SHOW statements -->
PREPARE show_tables FROM 'SHOW TABLES';
EXECUTE show_tables;

PREPARE show_table_status FROM 'SHOW TABLE articles STATUS';
EXECUTE show_table_status;

PREPARE describe_table FROM 'DESCRIBE articles';
EXECUTE describe_table;

<!-- Test 4: JSON operations -->
PREPARE json_query FROM 'SELECT id, title, tags.type, tags.difficulty FROM articles WHERE JSON_EXTRACT(tags, "$.type") = "guide"';
EXECUTE json_query;

<!-- Test 5: Simple category grouping -->
PREPARE category_group FROM 'SELECT category_id, COUNT(*) as count FROM articles GROUP BY category_id';
EXECUTE category_group;

<!-- Test 6: Large query string (test query length limits) -->
PREPARE long_query FROM 'SELECT id, title, content, category_id, publish_date, tags, 
CASE 
  WHEN category_id = 1 THEN "Tutorial Content"
  WHEN category_id = 2 THEN "Guide Content" 
  WHEN category_id = 3 THEN "News Content"
  ELSE "Other Content"
END as content_type,
CASE 
  WHEN publish_date > 1672617600 THEN "Recent"
  ELSE "Older" 
END as recency,
LENGTH(title) as title_length,
LENGTH(content) as content_length,
UNIX_TIMESTAMP() - publish_date as age_seconds
FROM articles 
WHERE category_id IN (1, 2, 3) 
  AND LENGTH(title) > 10 
  AND publish_date > 1672531200
ORDER BY publish_date DESC, id ASC
LIMIT 10';
EXECUTE long_query;

<!-- Test 7: Unicode and special characters -->
INSERT INTO articles(id, title, content, category_id) VALUES 
(5, 'TÃ«st Ãœtf8 Ã‡hÃ ractÃ©rs', 'Content with Ã©mojis ðŸš€ and spÃ«cial chars: Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«', 3);

PREPARE unicode_test FROM 'SELECT * FROM articles WHERE title LIKE "%TÃ«st%"';
EXECUTE unicode_test;

PREPARE emoji_test FROM 'SELECT * FROM articles WHERE content LIKE "%ðŸš€%"';
EXECUTE emoji_test;

<!-- Test 8: Complex aggregations -->
PREPARE complex_aggregation FROM 'SELECT 
  category_id,
  COUNT(*) as article_count,
  AVG(LENGTH(title)) as avg_title_length,
  MAX(publish_date) as latest_publish,
  MIN(publish_date) as earliest_publish,
  GROUP_CONCAT(DISTINCT LEFT(title, 20)) as title_previews
FROM articles 
GROUP BY category_id 
HAVING COUNT(*) > 0
ORDER BY article_count DESC';
EXECUTE complex_aggregation;

<!-- Test 9: Subquery-like operations -->
PREPARE subquery_simulation FROM 'SELECT a1.*, 
  (SELECT COUNT(*) FROM articles a2 WHERE a2.category_id = a1.category_id) as category_total,
  (SELECT name FROM categories c WHERE c.id = a1.category_id) as category_name
FROM articles a1 
WHERE a1.publish_date > 1672531200';
EXECUTE subquery_simulation;

<!-- Test 10: Multiple prepared statements with similar names -->
PREPARE stmt_a FROM 'SELECT COUNT(*) as total FROM articles';
PREPARE stmt_aa FROM 'SELECT COUNT(*) as total FROM categories';  
PREPARE stmt_aaa FROM 'SELECT 1 as test';
PREPARE stmt_b FROM 'SELECT 2 as test';

EXECUTE stmt_a;
EXECUTE stmt_aa;
EXECUTE stmt_aaa;
EXECUTE stmt_b;

<!-- Test 11: Resource stress test - many prepared statements -->
PREPARE stress_1 FROM 'SELECT 1';
PREPARE stress_2 FROM 'SELECT 2';
PREPARE stress_3 FROM 'SELECT 3';
PREPARE stress_4 FROM 'SELECT 4';
PREPARE stress_5 FROM 'SELECT 5';
PREPARE stress_6 FROM 'SELECT 6';
PREPARE stress_7 FROM 'SELECT 7';
PREPARE stress_8 FROM 'SELECT 8';
PREPARE stress_9 FROM 'SELECT 9';
PREPARE stress_10 FROM 'SELECT 10';

EXECUTE stress_5;
EXECUTE stress_1;
EXECUTE stress_10;

<!-- Test 12: Real-time index operations -->
PREPARE flush_table FROM 'FLUSH TABLE articles';
EXECUTE flush_table;

PREPARE optimize_table FROM 'OPTIMIZE TABLE articles';
EXECUTE optimize_table;

<!-- Test 13: Complex WHERE conditions -->
PREPARE complex_where FROM 'SELECT * FROM articles WHERE 
  (category_id = 1 AND LENGTH(title) > 15) OR 
  (category_id = 2 AND publish_date > 1672617600) OR
  (category_id = 3 AND content LIKE "%guide%")
ORDER BY 
  CASE WHEN category_id = 1 THEN publish_date END DESC,
  CASE WHEN category_id = 2 THEN LENGTH(title) END ASC,
  id';
EXECUTE complex_where;

<!-- Test 14: EXPLAIN operations -->
PREPARE explain_query FROM 'EXPLAIN SELECT * FROM articles WHERE MATCH("database") ORDER BY publish_date';
EXECUTE explain_query;

<!-- Test 15: Edge case - very long identifier names -->
PREPARE very_long_statement_name_that_tests_identifier_length_limits FROM 'SELECT "long name test" as result';
EXECUTE very_long_statement_name_that_tests_identifier_length_limits;

<!-- Test 16: Special SQL constructs -->
PREPARE union_like FROM 'SELECT title, "article" as type FROM articles WHERE category_id = 1';
EXECUTE union_like;

PREPARE case_when FROM 'SELECT title,
  CASE 
    WHEN category_id = 1 THEN "Educational"
    WHEN category_id = 2 THEN "Reference" 
    WHEN category_id = 3 THEN "Current"
    ELSE "Unknown"
  END as content_classification
FROM articles';
EXECUTE case_when;

<!-- Test 17: Error recovery - syntax errors in prepared statements -->
PREPARE syntax_error_1 FROM 'SELECT * FROMM articles';
PREPARE syntax_error_2 FROM 'SELEKT id FROM articles';
PREPARE syntax_error_3 FROM 'SELECT id, FROM articles';

<!-- Test 18: Cleanup and resource deallocation -->
DEALLOCATE PREPARE text_search;
DEALLOCATE PREPARE content_search;
DEALLOCATE PREPARE cross_table;
DEALLOCATE PREPARE show_tables;
DEALLOCATE PREPARE show_table_status;
DEALLOCATE PREPARE describe_table;
DEALLOCATE PREPARE json_query;
DEALLOCATE PREPARE category_group;
DEALLOCATE PREPARE long_query;
DEALLOCATE PREPARE unicode_test;
DEALLOCATE PREPARE emoji_test;
DEALLOCATE PREPARE complex_aggregation;
DEALLOCATE PREPARE subquery_simulation;
DEALLOCATE PREPARE stmt_a;
DEALLOCATE PREPARE stmt_aa;
DEALLOCATE PREPARE stmt_aaa;
DEALLOCATE PREPARE stmt_b;
DEALLOCATE PREPARE stress_1;
DEALLOCATE PREPARE stress_2;
DEALLOCATE PREPARE stress_3;
DEALLOCATE PREPARE stress_4;
DEALLOCATE PREPARE stress_5;
DEALLOCATE PREPARE stress_6;
DEALLOCATE PREPARE stress_7;
DEALLOCATE PREPARE stress_8;
DEALLOCATE PREPARE stress_9;
DEALLOCATE PREPARE stress_10;
DEALLOCATE PREPARE flush_table;
DEALLOCATE PREPARE optimize_table;
DEALLOCATE PREPARE complex_where;
DEALLOCATE PREPARE explain_query;
DEALLOCATE PREPARE very_long_statement_name_that_tests_identifier_length_limits;
DEALLOCATE PREPARE union_like;
DEALLOCATE PREPARE case_when;

<!-- Test 19: Verify all statements are deallocated -->
EXECUTE text_search;
EXECUTE stress_5;

<!-- Clean up tables -->
DROP TABLE articles;
DROP TABLE categories;

</sphinxql>
</sphqueries>

</test>